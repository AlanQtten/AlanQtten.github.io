<script setup>
import {
  QuizProvider,
  Quiz,
  Radio,
  Option
} from "../../components/quiz";

</script>

# panic还是不panic

什么时候该使用`panic!`，什么时候该返回`Result`呢？当程序panic时，就没有回头路了。你可以在所有错误里使用`panic!`，不管有没有办法恢复，但这样等于决定了程序永远是无法恢复的。当你选择返回`Result`时，你给了调用者选择。调用者会选择跟他们的场景合适的恢复方式，或者决定这个`Err`是不可恢复的，他可以调用`panic!`并将你的可恢复错误变为不可恢复的错误。因此，在定义一个可能失败的函数时，返回`Result`是一个好的选择。

在一些情况下，比如范例、原型代码、测试代码中，`panic!`是更好的选择。我们可以研究一下为什么，然后讨论一些计算机无法看出失败，而你作为人类，可以看出来的情况。本章最后会提供一些关于在库代码中何时选择恐慌的决策指南。

## 例子，原型和测试代码

当你在写一些验证概念的例子时，写一些完整的错误处理可能会让代码没那么清晰。这种情况下，调用一些类似`unwrap`的、可能导致panic的方法也是可以接受的。这样可以提供类似占位符的概念，你的应用可以根据剩下的代码情况进行错误处理。

类似的，在你决定好如何处理错误前，`unwrap`和`expect`方法在开发原型时也是很称手的。它们可以留下一些标记，待未来你希望让程序更健壮时改进。

如果一个方法没有通过测试，即使这个方法不是本次要测试的功能，你可能也希望整个测试都是失败的。由于`panic!`是测试标记为失败的痕迹，这种情况下调用`unwrap`和`expect`再合适不过了。

## 你比编译器掌握了更多信息的情况

如果你有一些其他逻辑来保证`Result`的返回值是`Ok`，那么调用`unwrap`或`expect`也很合适，但是编译器无法理解这些逻辑。你仍然需要处理`Result`值：不管你进行的是什么操作，它仍然存在失败的可能性，哪怕在你特定的逻辑里它是不可能失败的。如果你能够保证通过手动的代码检查来构造永远不会出现`Err`变体，那么调用`unwrap`就是最完美的选择，如果你能把这段代码永远不会产生`Err`变体的原因写在`expect`的参数里，那就更好了：

```rust
    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
```

我们通过一个字符串字面量创建了一个`IpAddr`实例。我们可以看到`127.0.0.1`是一个合法的IP地址，所以这里使用`expect`是可以接受的。然而，使用一个硬编码的、合法的字符串字面量并不会改变`parse`方法的返回值：我们仍然得到了一个`Result`，编译器仍然需要确保我们考虑`Result`为`Err`变体的可能性，因为编译器还没有聪明到能够明白这里的字符串是一个永远有效的IP地址。如果IP地址不是硬编码的，而是从用户侧输入的，*确实*存在失败的可能性，我们就必须用更加合适的方式处理`Result`。我们的代码里提到了这个字符串是硬编码的，这样在未来如果字符串的来源要进行变动，也会提醒我们对`expect`进行更好的处理。

## 错误处理指南

如果你的代码在错误的情况下会进入不好的状态，那么使用panic也是可取的。这种上下文里，*不好的状态*就是一些假设、保证、约定或者不变量被破坏了，比如无效的值、互相矛盾的值、缺失的值被传入了你的代码————一般为下述情况的若干种：

- 不好的状态是意料之外的事，而不是一些类似用户输入格式错误那种时有发生的错误。
- 某个节点后，你的代码依赖于某个状态，且没有在每一步都进行检查。
- 对于你的类型来说，无法对信息进行编码。我们会在第十七章对这部分内容进行深入讨论。

如果某些人调用了你的代码，传递了没有意义的值，这种情况下最好返回错误，让库用户的使用者来决定怎么继续。然而，如果继续下去可能不安全甚至会造成一些破坏，那么最好的选择就是调用`panic!`并警告库的使用者，好让他们在开发阶段就能发现并解决问题。类似的，如果你调用了外部的代码，其返回值你无法处理，那么`pnaic!`也比较合适。

然而，如果错误是在预期内的，那么返回`Result`比调用`panic!`更合适。比如要对一个不合规的数据进行转换，或者一个HTTP请求返回了表示你已达到请求上限的状态码。这些情况下，`Result`就可以表示一种预期内的错误的可能性，调用者需要对其进行处理。

当你的代码执行的操作可能因为无效值而使用户处于危险中时，你的代码应该先验证这些值是否有效，并在无效时引发panic。大部分情况下这是为了安全：试图对无效值进行操作可能会破坏你代码的可靠性。这也是标准库在你试图进行内存越界操作时调用`panic!`的原因：访问不属于当前数据结构的数据是很常见的安全问题。函数一般都有*合约*：它们的行为只在输入值符合某些要求的情况下才是有保障的。如果有人违反了合约，那么你可以panic，因为这种情况下漏洞是在用户侧的，这些漏洞是你希望用户去处理的。实际上，调用者也没有合理的恢复理由；调用的*开发者*需要修复这些代码。函数的合约，特别是什么样的违反会导致panic，应当在函数的API文档中加以解释说明。

然而，在代码中进行无处不在的错误检查是非常啰嗦、烦人的。幸运的是，你可以使用Rust的类型系统（进而借助编译器的类型检查）来替你完成检查。如果你的函数参数是一个特定的类型，那么你可以使用它，因为编译器已经保证了传入的类型是匹配的。比如，如果你的类型不是`Option`，你的程序期望*有值*而不是*无值*。你的代码无需对`Some`和`None`变体进行处理：只需要考虑有值的场景。试图尝试可能无值的内容无法通过编译，你的函数也就省去了那部分类型检查。再举个例子，比如你可以设置参数为`u32`，排除掉参数是负数的情况。

## 创建自定义类型协助检查

让我们来试试使用Rust的类型系统，通过创建自定义类型来保障我们的值是有效的。回顾第二章的猜数游戏，这里需要用户输入一个1-100之间的值。在用它和随机数比对前，我们并没有检查它的范围是否合法；我们只校验了用户的输入是正数。这种情况下，后果并不严重，用户输入的“过高”或“过低”的数字并不影响结果。但如果能引导用户进行有效的猜测，并在用户猜测的数字超出范围与输入字母（例如）时有不同的行为，也是一个有用的改进。

一个办法是接受一个`i32`而不是`u32`来避免潜在的负数，然后再添加范围检查：

```rust
    loop {
        // 略

        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // 略
        }
    }
```

`if`表达式检查了值是否超出了范围，并告诉了用户问题所在，然后调用了`continue`来开启下一次循环，也就是让用户进行下一次猜测。在`if`表达式后，我们可以继续进行神秘数和`guess`的比较，此时已经可以确定`guess`的值是在1-100之间的。

然而，这并不理想：如果程序还涉及了更多对于1-100之间数的操作或要求，这样的检查就会很啰嗦（还可能会影响性能）。

作为改进，我们可以创建一个新类型，然后将检查作为创建这个类型实例的检查，而不是分散书写它的校验。这样，只要使用了我们新类型的函数就可以通过签名来知道这个值的各种情况。下面的代码就创建了一个`Guess`类型，它的`new`方法只会在参数在1-100之间时创建`Guess`实例。

```rust
pub struct Guesst {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

首先，我们定义了一个名为`Guess`的结构体，它包含一个类型为`i32`的字段`value`。这里存储了数字。

然后我们给`Guess`类型实现了`new`关联函数，它用于创建`Guess`实例。`new`函数只接收一个参数，它的类型是`i32`，它会返回一个`Guess`。函数体内的代码检查了`value`来保证它在1-100之间。如果`value`没有通过检查，那么我们会调用`panic!`，它会警告开发者它们有一个漏洞需要处理，因为通过一个超出范围的`value`来创建`Guess`违反了`Guess::new`所依赖的合约。`Guess::new`会panic的条件应该在它公开API的文档中被讨论到；我们会在第14章讨论这部分内容。如果`value`通过了测试，那么函数会创建一个新的`Guess`类型，将`value`设置为它的参数，并返回这个`Guess`。

然后，我们实现了一个方法`value`，它借用了`self`，且没有其他参数，它返回一个`i32`。这样的方法有时候被称为*getter*，因为它的目的就是为了从实例中获取某些字段值。这样的公共方法是很有必要的，因为`value`是私有的。这件事很重要，这样外侧的代码才无法直接对`value`进行设置值：调用者只能通过`Guess::new`创建`Guess`实例，因此保证了`Guess`无法持有不通过`Guess::new`检查的值。

一个函数的参数或返回值在1-100之间时，可以在函数签名中声明接受或返回`Guess`类型，而不是`i32`类型，并且不需要在函数体内进行任何额外的检查。

::: details 小测（1）
<QuizProvider>
<Quiz>
<template #description>

解析：这里，开发者期望使用的是*可恢复的*错误（`Result`）。如果工具的使用者传入了一个不合规的标志位，那么工具应该提供一些正确格式的展示来帮助用户。而panic只会显示程序的报错信息，对用户体验没有什么帮助。

</template>
<template #quiz>

一个Rust开发者在设计一个库，用于写入一个命令行接口。作为这个库的一部分，需要实现一个处理用户输入标识的函数。哪一个实现更合适？

```rust
fn parse_flag_v1(flag: &str) -> Result<String, String> {
    match flag.strip_prefix("--") {
        Some(no_dash) => Ok(no_dash.to_string()),
        None => Err(format!("Invalid flag {flag}"))
    }
}

fn parse_flag_v2(flag: &str) -> String {
    match flag.strip_prefix("--") {
        Some(no_dash) => no_dash.to_string(),
        None => panic!("Invalid flag {flag}")
    }
}
```

<Radio>
<Option label="parse_flag_v1" answer />
<Option label="parse_flag_v2" />
</Radio>
</template>
</Quiz>
</QuizProvider>
:::

## 总结

Rust的错误处理功能设计之初就是为了帮助你构造健壮的代码。`panic!`宏标记了程序已经进入了无法处理的状态，允许你告诉进程停下来，而不是使用无效的值继续。`Result`枚举则借助Rust的类型系统来表达了可能失败的、可恢复的操作。你可以使用它来告诉调用者去处理潜在的成功或失败。在合适的情况下分别使用`panic!`和`Result`可以让你的代码在面对未知问题时更加可靠。

注意你已经见识过了标准库枚举`Option`和`Result`中泛型的实用性，下面我们会讨论泛型的工作原理，以及你如何在你的代码中使用它。
