# 无畏并发

安全、高效地处理并发程序是另一个Rust的主要目标。随着越来越多的计算机利用其多个处理器，*并发編程（concurrent programming）*（程序的不同部分独立执行）和*并行编程（parallel programming）*（程序的不同部分同时执行）变得越来越重要。历史上，各种编程语言在这些场景下都会十分困难，且容易出错：Rust希望改变这一点。

起初，Rust团队认为保证内存安全和避免并发问题是需要用不同方法解决的两个独立的挑战。但随着时间的推移，团队成员发现所有权和类型系统对管理内存安全*和*并发问题来说都是十分有用的工具！通过所有权和类型检查，许多并发问题从运行时提前到了编译时。因此，你不需要花费大把时间来重现问题发生的准确时机，错误的代码无法通过编译，且会给出解释。结果就是，你可以在将代码发布到生产前就修复掉这些问题。我们给这种Rust特性起名叫*无畏并发（fearless concurrency）*。无畏并发使得你可以开发没有细微错误的代码，且可以在不引入任何额外问题的情况下轻松地重构代码。

> [!NOTE]
> 为了简单，我们将大部分问题都称为*并发（concurrent）*，而没有说*并发和/或并行（concurrent and/or parallel）*。如果本书是关于并发和/或并行的，我们会更具体。对这一章而言，你可以在心中默认*并发*为*并发和/或并行*。

许多语言在讲述处理并发问题时总会有些教条主义。比如，`Erlang`设计了优雅的消息传递功能，但在线程之间共享状态的方式却很晦涩。高级语言往往只会对可行的方案做支持，因为高级语言倾向于放弃一些控制来实现更稳定的抽象。然而，低级语言却希望对所有可预见的场景提供解决方案，几乎不会留有抽象空间。因此，Rust提供了一系列的工具来为问题建模，你可以根据你的方案要求来选择最合适的方式。

下面是本章要讨论的一系列主题：

- 如何创建线程来让多个代码块同时运行
- 并发的*消息传递*，在线程直接建立消息通道
- 并发*共享状态*，让多线程可以访问同一份数据
- `Sync`和`Send`trait，标准库提供的保障用户自定义类型线程安全的工具
